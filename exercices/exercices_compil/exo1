// Dans le premier cas (avec i est un uint8_t), gcc donne :
g:
	mov	r0, #0
	bx	lr
	.size	g, .-g
	.align	2
	.global	f
	.syntax unified
	.arm
	.type	f, %function
f:
	ldr	r3, .L5
	ldr	r2, [r3]
	mov	r3, #0
.L3:
	add	r3, r3, #1
	and	r3, r3, #255
	cmp	r3, r2
	bls	.L3
.L6:
	.align	2
.L5:
	.word	.LANCHOR0
	.size	f, .-f
	.global	a
	.bss
	.align	2
	.set	.LANCHOR0,. + 0
	.type	a, %object
	.size	a, 4
a:
	.space	4
	.ident	"GCC: (GNU) 11.3.1 20220712"

// Dans le second cas (avec i est un unsigned int), gcc donne :
g:
	mov	r0, #0
	bx	lr
	.size	g, .-g
	.align	2
	.global	f
	.syntax unified
	.arm
	.type	f, %function
f:
	ldr	r3, .L5
	ldr	r2, [r3]
	mov	r3, #0
.L3:
	add	r3, r3, #1
	cmp	r2, r3
	bcs	.L3
.L6:
	.align	2
.L5:
	.word	.LANCHOR0
	.size	f, .-f
	.global	a
	.bss
	.align	2
	.set	.LANCHOR0,. + 0
	.type	a, %object
	.size	a, 4
a:
	.space	4
	.ident	"GCC: (GNU) 11.3.1 20220712"

// Les différences se trouvent dans .L3 : 
// Dans le cas où on a un uint8_t, r3 prend la valeur de r3 & 255 après avoir fait i++ (on fait le modulo pour ne pas qu'il dépasse la valeur 255)
// Dans le cas où on a un unisgned int, r3 ne passe pas par cette étape (car il peut dépasser 255)
